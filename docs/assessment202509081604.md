_Complete assessment_ of the latest repo + deployed contracts and a **production‚Äëready coding sprint** that: (1) forces token burn üî• to be executed by the **AGI Employer‚Äôs wallet** using the **existing AGIALPHA** token, (2) gates _all_ actors by a mandatory TaxPolicy acceptance, (3) keeps expired stakes & unclaimed fees tax‚Äëneutral for the platform, (4) preserves DAO/gov participation without creating platform tax exposure, (5) locks the system to **\$AGIALPHA @ 0xA61a‚Ä¶a1fA**, (6) enforces runtime ENS subdomain identity (with **NameWrapper fallback + Merkle bypass**), (7) is Etherscan‚Äëdeployable with owner updatability & full control, and (8) ships canonical Markdown guides for browser‚Äëonly mainnet launch and operations.

---

## 0) What I verified right now

**Repo (latest)**
The README clearly states v2 is the only supported line, mandates ENS identities (`*.agent.agi.eth` for agents, `*.club.agi.eth` for validators), hard‚Äëcodes \$AGIALPHA for payments/stakes, and provides Etherscan deployment wiring & owner controls (setters across modules). It also documents emergency allowlists in `IdentityRegistry` and v2 wiring steps. ([GitHub][1])

**AGIALPHA token (0xA61a‚Ä¶a1fA)**
Contract is **verified** as `AGIAlphaToken` and **inherits `ERC20Burnable`** (OpenZeppelin v5), which exposes **`burn(uint256)` and `burnFrom(address,uint256)`** callable by external addresses; decimals default to **18** (no override in the base, OZ ERC20 default). You can also see explicit `ERC20Burnable` and its `burn`/`burnFrom` functions in the verified sources. ([Ethereum (ETH) Blockchain Explorer][2])

**AGIJobManager v1 (0x0178‚Ä¶a477)**
Contract is **verified** as `AGIJobManager`. The code defines ENS interfaces and an explicit **`NameWrapper` interface** which indicates a **NameWrapper fallback** is present in ownership checks; the file outline shows ENS & NameWrapper usage and a private ownership verification helper (the `_verifyOwnership` you want to port). ([Ethereum (ETH) Blockchain Explorer][3])

> Conclusion: The canonical token exists with a **public burn** API; the v1 manager enforces ENS with NameWrapper fallback; v2 repo text mandates ENS identities and v2‚Äëmodule wiring. All of this aligns with the sprint below.

---

## 1) Design decisions that guarantee **burn by employer**, **tax neutrality for platform**, & **traceability**

### 1.1 Burn model (strict employer‚Äëside burn)

- **Rule**: The platform contracts **MUST NOT** call `AGIALPHA.burn`/`burnFrom` during job flows. Only the **employer‚Äôs EOA** executes the burn via the AGIALPHA contract UI (Etherscan) or the frontend.
- **How we enforce/process it on‚Äëchain**:

  - We add a **`BurnReceipts`** mechanism: the employer submits the **burn tx hash, amount, and block** via `JobRegistry.submitBurnReceipt(jobId, txHash, amount, blockNumber)`.
  - We **do not read logs on-chain** (impossible in EVM). Instead, **validators** (already a trust/quality layer) must **commit‚Äëreveal** votes that _explicitly include the burn tx hash & amount_ (off‚Äëchain verified on Etherscan) in their preimage.
  - **ValidationModule** rejects approvals unless a valid **burn receipt** is present for the job and the validator‚Äôs reveal matches that receipt. The platform remains tax‚Äëneutral because:

    - It never executes a burn, never receives fees, and never benefits from burn economics.
    - **All tax burdens** remain with active parties (employers burn/dispose, validators/agents receive income).

- **UX**: The frontend/Etherscan guide supplies a **one‚Äëclick** path: (i) employer calls `AGIALPHA.burn(amount)` from their wallet, (ii) copy burn tx hash, (iii) call `JobRegistry.submitBurnReceipt`.

> This pushes the verification duty to **validators**‚Äîwhich you explicitly want to bear obligations‚Äîwhile keeping the platform neutral.

### 1.2 Token movement & custody

- **StakeManager** continues to hold **stakes** (escrow) for slashing‚Äîescrow is not platform income and creates **no tax event for the platform**.
- **Agent payout** may be **‚Äúpush‚Äù from employer** (direct transfer) or ‚Äúpull‚Äù via **`permitAndTransferFrom`** in AGIALPHA (present in token), but **the burn remains separate & employer‚Äëcalled**. The platform **never** takes a fee. ([Ethereum (ETH) Blockchain Explorer][2])

### 1.3 Expired stakes / unclaimed fees (tax‚Äëneutral for platform)

- **Unclaimed fees** accumulate in **`FeePool`** under **per‚Äëbeneficiary claim slots** (not platform‚Äôs balance conceptually); **no fees** are owned by the platform.
- **Expired stakes** are either:

  - **Redistributed** to active **validators** (income for validators, not platform), OR
  - **Remain claimable indefinitely** (simplest jurisdiction‚Äëagnostic approach), OR
  - **Governance‚Äëdecided sink**: sent to **DAO Treasury** (not the platform corp) _or_ burned by a **DAO‚Äëowned EOA** calling `AGIALPHA.burn()` from its wallet (still **not** the platform).
    In all options, **the platform never recognizes revenue**.

### 1.4 DAO & treasury participation

- **Treasury** / **Governance** addresses (multisig/timelock) can receive allocations from FeePool or slashing‚Äî**these are DAO assets**. The _platform corporation_ receives **nothing**. All governance flows use **`setGovernance`/`transferOwnership`** to route control away from a single key.

---

## 2) **Coding sprint backlog** (v2) ‚Äî outcome‚Äëoriented, owner‚Äëcontrollable, Etherscan‚Äëfirst

> Each item includes **what to change**, **acceptance criteria**, and **files to touch**. Names assume `contracts/‚Ä¶` per repo; owner controls follow the repo‚Äôs existing `setGovernance`/`transferOwnership` pattern. (Repo already documents these setters and wiring.) ([GitHub][1])

### EPIC A ‚Äî **Hard‚Äëlock \$AGIALPHA**

**A1. Constants**

- **Add** `Constants.sol` with:

  ```solidity
  // contracts/Constants.sol
  // SPDX-License-Identifier: MIT
  pragma solidity ^0.8.24;
  library Constants {
      address constant AGIALPHA = 0xA61a3B3a130a9c20768EEBF97E21515A6046a1fA;
      uint8 constant AGIALPHA_DECIMALS = 18;
  }
  ```

- **Acceptance**: All modules that touch ERC20 **read `Constants.AGIALPHA`**; no other ERC20 accepted.
- **Touch**: `StakeManager.sol`, `JobRegistry.sol`, `ValidationModule.sol`, `FeePool.sol`, `DisputeModule.sol` (constructor checks or immutable set), `ReputationEngine.sol` (if any token math), and any helper libraries.

**A2. Token guard**

- **Require** in constructors or `initialize`: `require(_token == Constants.AGIALPHA, "AGIALPHA only");` (or remove `_token` param entirely and use the constant).

**A3. Events for traceability**

- Add consistent events (see EPIC D).

> Rationale: Repo already states v2 assumes **18‚Äëdecimals** and a **fixed AGIALPHA** address; we codify it _immutably_. ([GitHub][1])

---

### EPIC B ‚Äî **TaxPolicy gating everywhere**

**B1. `TaxPolicy.sol`**

```solidity
// contracts/TaxPolicy.sol
pragma solidity ^0.8.24;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract TaxPolicy is Ownable {
    string  public currentCid; // IPFS CID for canonical policy
    mapping(address => bool) public accepted;

    event TaxPolicyUpdated(string cid);
    event TaxPolicyAccepted(address indexed who, string cid, uint256 ts);

    function setCurrentCid(string calldata cid) external onlyOwner {
        require(bytes(cid).length>0, "cid");
        currentCid = cid; emit TaxPolicyUpdated(cid);
    }
    function acceptPolicy(string calldata cid) external {
        require(keccak256(bytes(cid))==keccak256(bytes(currentCid)), "cid mismatch");
        accepted[msg.sender]=true; emit TaxPolicyAccepted(msg.sender, cid, block.timestamp);
    }
    function hasAccepted(address who) external view returns (bool) { return accepted[who]; }
}
```

**B2. `TaxGated.sol` mixin**

```solidity
// contracts/lib/TaxGated.sol
pragma solidity ^0.8.24;
interface ITaxPolicy { function hasAccepted(address) external view returns (bool); }
abstract contract TaxGated {
    ITaxPolicy public taxPolicy;
    event TaxPolicySet(address indexed policy);
    function _setTaxPolicy(address p) internal { taxPolicy = ITaxPolicy(p); emit TaxPolicySet(p); }
    modifier taxAccepted() { require(taxPolicy.hasAccepted(msg.sender), "Accept TaxPolicy"); _; }
}
```

**B3. Enforce in all flows**

- **Employers**: `JobRegistry.createJob`, `JobRegistry.cancelJob`, any employer‚Äëinitiated updates ‚Üí `taxAccepted`.
- **Agents**: `JobRegistry.applyForJob`, `JobRegistry.requestJobCompletion` ‚Üí `taxAccepted`.
- **Validators**: `ValidationModule.commit(...)`, `ValidationModule.reveal(...)`, `disapprove...` ‚Üí `taxAccepted`.
- **Disputes**: `DisputeModule.raiseDispute`, `resolveDispute` ‚Üí `taxAccepted`.

**Acceptance**: any call from employers/agents/validators must revert unless the caller has accepted the current policy; owner can `setCurrentCid` to rotate policy and require re‚Äëacceptance (if desired UX).

---

### EPIC C ‚Äî **ENS identity enforcement with v1 parity (\_verifyOwnership)**

> The v1 **AGIJobManager** verified code uses ENS and **NameWrapper** fallback, plus a **Merkle bypass** for emergency allowlists. We port that **exact behavior** into v2 `IdentityRegistry` and **use it at both agent application and validator voting**. The v1 file outline shows ENS + NameWrapper interfaces ‚Äî we mirror that. ([Ethereum (ETH) Blockchain Explorer][3])

**C1. `IdentityRegistry.sol`**

```solidity
// contracts/IdentityRegistry.sol
pragma solidity ^0.8.24;

interface ENS { function resolver(bytes32 node) external view returns (address); }
interface Resolver { function addr(bytes32 node) external view returns (address); }
interface NameWrapper { function ownerOf(uint256 id) external view returns (address); }

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

contract IdentityRegistry is Ownable {
    ENS         public ens;
    NameWrapper public nameWrapper;
    bytes32     public agentRootNode;     // namehash("agent.agi.eth")
    bytes32     public clubRootNode;      // namehash("club.agi.eth")
    bytes32     public agentMerkleRoot;   // emergency allowlist
    bytes32     public validatorMerkleRoot;

    event ENSSet(address ens);
    event NameWrapperSet(address wrapper);
    event RootsSet(bytes32 agentRoot, bytes32 clubRoot);
    event MerkleRootsSet(bytes32 agentRoot, bytes32 validatorRoot);

    function setENS(address _ens) external onlyOwner { ens = ENS(_ens); emit ENSSet(_ens); }
    function setNameWrapper(address _nw) external onlyOwner { nameWrapper = NameWrapper(_nw); emit NameWrapperSet(_nw); }
    function setAgentRootNode(bytes32 n) external onlyOwner { agentRootNode = n; _emitRoots(); }
    function setClubRootNode(bytes32 n)  external onlyOwner { clubRootNode  = n; _emitRoots(); }
    function _emitRoots() internal { emit RootsSet(agentRootNode, clubRootNode); }
    function setAgentMerkleRoot(bytes32 mr) external onlyOwner { agentMerkleRoot = mr; emit MerkleRootsSet(agentMerkleRoot, validatorMerkleRoot); }
    function setValidatorMerkleRoot(bytes32 mr) external onlyOwner { validatorMerkleRoot = mr; emit MerkleRootsSet(agentMerkleRoot, validatorMerkleRoot); }

    // --- EXACT parity behavior conceptually with v1 ---
    function _verifyOwnership(address claimant, bytes32 node, bytes32[] memory merkleProof, bool isValidator) internal view returns (bool) {
        // 1) Merkle bypass (emergency allowlist)
        bytes32 root = isValidator ? validatorMerkleRoot : agentMerkleRoot;
        if (root != bytes32(0) && merkleProof.length > 0) {
            if (MerkleProof.verify(merkleProof, root, keccak256(abi.encodePacked(claimant)))) return true;
        }
        // 2) Resolver.addr(node) == claimant
        address resolver = ens.resolver(node);
        if (resolver != address(0)) {
            try Resolver(resolver).addr(node) returns (address a) {
                if (a == claimant) return true;
            } catch {}
        }
        // 3) NameWrapper fallback ownerOf(uint256(node)) == claimant
        if (address(nameWrapper) != address(0)) {
            uint256 id = uint256(node);
            try nameWrapper.ownerOf(id) returns (address ow) {
                if (ow == claimant) return true;
            } catch {}
        }
        return false;
    }

    function assertAgent(address who, bytes32 labelhash, bytes32[] calldata proof) external view returns (bool) {
        bytes32 node = keccak256(abi.encodePacked(agentRootNode, labelhash));
        return _verifyOwnership(who, node, proof, false);
    }
    function assertValidator(address who, bytes32 labelhash, bytes32[] calldata proof) external view returns (bool) {
        bytes32 node = keccak256(abi.encodePacked(clubRootNode, labelhash));
        return _verifyOwnership(who, node, proof, true);
    }
}
```

> This reproduces the **Merkle bypass and NameWrapper fallback** behavior you requested, aligned with the v1 verified code‚Äôs structure and interfaces. ([Ethereum (ETH) Blockchain Explorer][3])

**C2. Apply checks in both places**

- **Agent application path**: in `JobRegistry.applyForJob(...)` require `identity.assertAgent(msg.sender, labelhash, proof)`.
- **Validator commit/reveal paths**: in `ValidationModule.commit...` and `reveal...` require `identity.assertValidator(msg.sender, labelhash, proof)`.

**Acceptance**: Any attempt to apply/validate without proving ownership of the right subdomain (or being on the Merkle allowlist) **reverts**. v1 parity achieved exactly as requested.

---

### EPIC D ‚Äî **Events & auditability (Etherscan‚Äëfriendly)**

Add structured events (names consistent across modules):

- **Identity**

  - `event IdentityVerified(address indexed who, bytes32 indexed node, bool validator);`

- **Tax**

  - Already in `TaxPolicy`: `TaxPolicyAccepted(who,cid,ts)` (B1 above).

- **Jobs**

  - `JobCreated(uint256 indexed jobId, address indexed employer, uint256 payout, string uri);`
  - `ApplicationSubmitted(uint256 indexed jobId, address indexed agent, bytes32 agentLabelhash);`
  - `AgentAssigned(uint256 indexed jobId, address indexed agent, bytes32 agentLabelhash);`
  - `CompletionRequested(uint256 indexed jobId, address indexed agent, string evidenceUri);`
  - `BurnReceiptSubmitted(uint256 indexed jobId, address indexed employer, bytes32 burnTxHash, uint256 amount, uint256 blockNumber);`

- **Validation**

  - `ValidationCommitted(uint256 indexed jobId, address indexed validator, bytes32 commitHash);`
  - `ValidationRevealed(uint256 indexed jobId, address indexed validator, bool approve, bytes32 burnTxHash);`
  - `JobApproved(uint256 indexed jobId)` / `JobRejected(uint256 indexed jobId)`

- **Staking/Slashing**

  - `StakeDeposited(address indexed who, uint8 role, uint256 amount);`
  - `StakeWithdrawn(address indexed who, uint256 amount);`
  - `Slashed(address indexed who, uint256 amount, address indexed beneficiary);`

- **Fees**

  - `FeesAccrued(address indexed beneficiary, uint256 amount, uint8 reason);`
  - `FeesClaimed(address indexed beneficiary, uint256 amount);`

**Acceptance**: All flows produce machine‚Äëparsable events for Etherscan log queries; no AGIALPHA internals are assumed‚Äîonly our events and AGIALPHA‚Äôs standard `Transfer`/`Approval`/`Burn` logs.

---

### EPIC E ‚Äî **Stake, slashing, & expired/unclaimed handling**

- **StakeManager**:

  - `depositStake(role, amount)` (AGIALPHA only), `withdrawStake`, `slash(address target, uint256 pct, address beneficiary)` (owner/governance‚Äëonly), cap per address, min stake per role; already hinted in README setter list. ([GitHub][1])
  - **Expired stakes**: configurable TTL; after TTL, stakes remain withdrawable by owner (**preferred**) or slashed by governance to **validator pool** (DAO/validators benefit, not platform).

- **FeePool**:

  - Only credits **beneficiaries**; **no default treasury** unless explicitly set to **DAO** via `setTreasury`.
  - **No platform skim**. Unclaimed can remain indefinitely or be clawed by **DAO** (not platform corp) via governance call into FeePool that transfers to DAO addresses; DAO then may burn from its own wallet.

**Acceptance**: No code path sends tokens to the platform corp; expired/unclaimed funds either remain claimable or move to DAO/validators, keeping the platform tax‚Äëneutral.

---

### EPIC F ‚Äî **Burn receipts in Job lifecycle**

- **JobRegistry** gains:

  - `submitBurnReceipt(jobId, burnTxHash, amount, blockNumber)` (employer‚Äëonly for that job).

- **ValidationModule**:

  - `commit(jobId, keccak256(burnTxHash || approve || salt))`
  - `reveal(jobId, burnTxHash, approve, salt)`; module checks a matching `BurnReceiptSubmitted` exists.

- **Owner controls**: owner can set min burn percentage per job type (as metadata) but **never executes burn**.

**Acceptance**: A job cannot be approved unless at least one valid burn receipt is on record and validators‚Äô reveals match it.

---

### EPIC G ‚Äî **DAO participation without platform tax exposure**

- Add/validate in FeePool/Reputation/StakeManager:

  - `setTreasury(address)` ‚Üí **must be DAO multisig/timelock**.
  - `setRewardRole(address)` to assign distributions to validator set or other non‚Äëplatform participants (matches README). ([GitHub][1])

- **Acceptance**: Only DAO/participants receive funds. Platform deployer can hand off control via `setGovernance`/`transferOwnership`.

---

### EPIC H ‚Äî **Owner updatability & control**

- Ensure **every** module exposes _exactly one_ owner/governance entrypoint:

  - For `StakeManager`, `JobRegistry`, `ValidationModule`, `DisputeModule`, `CertificateNFT`, `ReputationEngine`, `IdentityRegistry`, `FeePool`, `TaxPolicy`, `SystemPause`.
  - Wire `setGovernance` or `transferOwnership` (per module type) and **emit events**.

- Add `SystemPause` (Pausable) as global circuit breaker (owner‚Äëonly).

**Acceptance**: Owner can update **all relevant parameters** listed in README‚Äôs setter table; pausing halts external‚Äëfacing flows safely.

---

### EPIC I ‚Äî **Docs & Etherscan usability (canonical Markdown)**

Create/update the following Markdown files (at repo root or `/docs`), treated as **canonical**:

1. `docs/deployment-production-guide.md` (technical Etherscan + wiring)
2. `docs/agi-jobs-v2-production-deployment-guide.md` (non‚Äëtechnical operations)
3. `docs/ens-identity-policy.md` (runtime ENS checks, Merkle bypass, NameWrapper fallback)
4. `docs/tax-policy.md` (who accepts & how it gates flows)
5. `docs/burn-receipts.md` (how employers burn & submit receipts)
6. `docs/expired-unclaimed-handling.md` (options & tax neutrality)
7. `docs/security-checklist.md` (owner handoff, timelock, pausing)
8. Update `README.md` with quick links, single‚Äëscreen TL;DR

The repo already references several of these artifacts and Etherscan steps‚Äîwe‚Äôll make them concrete and **self‚Äëcontained** (no external assets). ([GitHub][1])

---

## 3) Concrete code diffs (concise)

Below are minimalistic, drop‚Äëin patterns to add during the sprint (snippets above already cover the core). Wire them:

- **IdentityRegistry** from EPIC C (`setENS`, `setNameWrapper`, roots, merkle roots, `_verifyOwnership`).
- In **JobRegistry**:

  ```solidity
  using Constants for *;
  import {TaxGated} from "./lib/TaxGated.sol";
  import {IdentityRegistry} from "./IdentityRegistry.sol";

  IdentityRegistry public identity;
  event BurnReceiptSubmitted(uint256 indexed jobId, address indexed employer, bytes32 burnTxHash, uint256 amount, uint256 blockNumber);

  function setIdentityRegistry(address _id) external onlyOwner { identity = IdentityRegistry(_id); }

  function createJob(uint256 payout, string calldata uri) external taxAccepted returns (uint256 id) { /* ... */ }
  function applyForJob(uint256 jobId, bytes32 agentLabelhash, bytes32[] calldata proof) external taxAccepted {
      require(identity.assertAgent(msg.sender, agentLabelhash, proof), "ENS/agent");
      /* ... */
  }
  function submitBurnReceipt(uint256 jobId, bytes32 burnTxHash, uint256 amount, uint256 blk) external {
      require(msg.sender == jobs[jobId].employer, "employer only");
      // store receipt; emit event
      emit BurnReceiptSubmitted(jobId, msg.sender, burnTxHash, amount, blk);
  }
  ```

- In **ValidationModule**:

  ```solidity
  function setIdentityRegistry(address _id) external onlyOwner { identity = IdentityRegistry(_id); }
  function commit(uint256 jobId, bytes32 commitHash, bytes32 validatorLabelhash, bytes32[] calldata proof) external taxAccepted {
      require(identity.assertValidator(msg.sender, validatorLabelhash, proof), "ENS/validator");
      // store commit
  }
  function reveal(uint256 jobId, bool approve, bytes32 burnTxHash, bytes32 salt) external taxAccepted {
      // check commit preimage and that JobRegistry has a burn receipt with burnTxHash
  }
  ```

---

## 4) **Technical** Etherscan mainnet deployment guide (browser‚Äëonly)

> This is **aligned to the v2 wiring** described in the README and expands it with the burn & tax controls. Record every deployed address as you go. ([GitHub][1])

**Prereqs**

- You have: **\$AGIALPHA** live at **`0xA61a3B3a130a9c20768EEBF97E21515A6046a1fA`**, ENS Registry, and (optional) NameWrapper mainnet addresses (public ENS).
- Decide the **governance owner** (EOA initially, later move to multisig/timelock).

**Module order**

1. **TaxPolicy** ‚Üí Deploy; call `setCurrentCid("<ipfs-cid-of-policy>")`.
2. **IdentityRegistry**

   - Deploy; call:

     - `setENS(<ENS_REGISTRY>)`
     - `setNameWrapper(<NAME_WRAPPER>)` (optional but recommended)
     - `setAgentRootNode(namehash("agent.agi.eth"))`
     - `setClubRootNode(namehash("club.agi.eth"))`
     - (Optional emergency) `setAgentMerkleRoot(0x0)`, `setValidatorMerkleRoot(0x0)`

3. **StakeManager** (constructor: none or owner only; token is **implicit via Constants**)

   - Post‚Äëdeploy setters: `setMinStake(role, amount)`, `setMaxStakePerAddress(x)`, `setTreasury(<DAO multisig>)`.

4. **FeePool** ‚Üí `setTreasury(<DAO multisig>)`.
5. **ReputationEngine** ‚Üí `setCaller(<modules that may update reputation>)`.
6. **CertificateNFT** ‚Üí set base URI later.
7. **ValidationModule**

   - `setCommitWindow(x)`, `setRevealWindow(y)`, `setValidatorBounds(min,max)`, `setApprovalThreshold(bps)`
   - **`setIdentityRegistry(<IdentityRegistry>)`**

8. **DisputeModule**

   - `setDisputeFee(amount)`, **`setTaxPolicy(<TaxPolicy>)`**, `setFeePool(<FeePool>)`.

9. **JobRegistry**

   - **`setModules(validation, stakeManager, reputation, dispute, certificate, feePool, [])`**
   - **`setTaxPolicy(<TaxPolicy>)`**
   - **`setIdentityRegistry(<IdentityRegistry>)`**

10. Wire **back‚Äëlinks**:

    - `StakeManager.setJobRegistry(<JobRegistry>)`
    - `ValidationModule.setJobRegistry(<JobRegistry>)`
    - `DisputeModule.setJobRegistry(<JobRegistry>)`
    - `CertificateNFT.setJobRegistry(<JobRegistry>)`
    - (If used) `StakeManager.setDisputeModule(<DisputeModule>)`

11. **Ownership handoff**

    - For each module, call `setGovernance` or `transferOwnership` to your **multisig/timelock**.

12. **System pause** (optional module): deploy `SystemPause`, wire modules to respect it, keep owner keys in multisig.

**Post‚Äëwiring smoke tests (Etherscan Write tabs)**

- Employer: `TaxPolicy.acceptPolicy(cid)`
- Agent: `TaxPolicy.acceptPolicy(cid)`
- Validator: `TaxPolicy.acceptPolicy(cid)`
- Agent stakes on `StakeManager.depositStake(role=AGENT, amount)`
- Employer `JobRegistry.createJob(payout, "ipfs://‚Ä¶")`
- Agent `applyForJob(jobId, agentLabelhash, proof)`
- Employer burns on **AGIALPHA**: Etherscan ‚Üí Contract ‚Üí `write` ‚Üí `burn(amount)` (**from employer wallet**). Copy tx hash.
- Employer `JobRegistry.submitBurnReceipt(jobId, burnTxHash, amount, blockNumber)`
- Validators: `ValidationModule.commit(...)` ‚Üí `reveal(...)`
- Observe `JobApproved` event.

---

## 5) **Non‚Äëtechnical** Etherscan usage guide (plain language)

**Before you start**

- Get some **AGIALPHA** tokens in your wallet.
- Register your **ENS subdomain**:

  - **Agents**: `yourname.agent.agi.eth`
  - **Validators**: `yourname.club.agi.eth`

- Accept the **Tax Policy** once.

**A) Employer ‚Äî create & complete a job**

1. Open **TaxPolicy** on Etherscan ‚Üí _Write_ ‚Üí `acceptPolicy` ‚Üí paste the policy CID ‚Üí **Write**.
2. Open **JobRegistry** ‚Üí _Write_ ‚Üí `createJob(payout, "ipfs://job-brief")` ‚Üí **Write** ‚Üí note the `jobId`.
3. When the job is done and validated off‚Äëchain, **burn your fee**:

   - Open **AGIALPHA** token ‚Üí _Write_ ‚Üí `burn(amountToBurn)` ‚Üí **Write** (this is your wallet).
   - Copy the **burn transaction hash** and block number.

4. Back on **JobRegistry** ‚Üí `submitBurnReceipt(jobId, burnTxHash, amount, blockNumber)` ‚Üí **Write**.
5. Validators will check your burn and vote. Watch for `JobApproved` on the **Events** tab.

**B) Agent ‚Äî stake & apply**

1. Open **TaxPolicy** ‚Üí `acceptPolicy`.
2. Open **StakeManager** ‚Üí `depositStake(role=1 /*AGENT*/, amount)`.
3. Open **JobRegistry** ‚Üí `applyForJob(jobId, agentLabelhash, proof)` (your labelhash is `keccak256("yourname")`; proof is only needed if you‚Äôre on the emergency allowlist; otherwise ENS ownership suffices).

**C) Validator ‚Äî commit & reveal**

1. **Accept Tax Policy** and **stake** as validator.
2. **Commit**: `ValidationModule.commit(jobId, commitHash, validatorLabelhash, proof)`
   (Commit hash = keccak256(burnTxHash || approve || salt).)
3. **Reveal**: `ValidationModule.reveal(jobId, approve, burnTxHash, salt)`.

**Notes**

- If your ENS is wrapped, the system accepts **NameWrapper** ownership.
- If you‚Äôre on a temporary emergency list, maintain your **Merkle proof** (available from the operator) for the call.

---

## 6) Style, formatting, and docs polish

- Keep **all images inlined as text** (no external assets).
- Ensure **single source of truth** for addresses in `docs/deployment-addresses.json`, referenced by guides.
- Add **one‚Äëscreen TL;DR** to the README with direct links to **Tax Policy**, **Deployment**, **ENS policy**, **Burn Receipts**, **Non‚Äëtechnical guide**.
- Match the repo‚Äôs existing Etherscan steps table, expanding them into **copy‚Äëpaste friendly** call sequences. ([GitHub][1])

---

## 7) Production‚Äëreadiness checklist

- **True employer‚Äëside burn**: Platform never calls `burn`/`burnFrom` in job flows. Burn proof goes through validator commit‚Äëreveal. **Pass** after EPIC F.
- **AGIALPHA only**: All modules guard against any other ERC‚Äë20. **Pass** after EPIC A.
- **ENS identity**: Runtime checks for agents & validators; **NameWrapper fallback**; **Merkle bypass**. **Pass** after EPIC C.
- **Tax gating**: All actor flows require `TaxPolicy.acceptPolicy`. **Pass** after EPIC B.
- **Expired/unclaimed**: No platform revenue; funds remain claimable or go to DAO/validators. **Pass** after EPIC E/G.
- **Owner updatability**: All module parameters updatable by owner; governance handoff documented. **Pass** after EPIC H + docs.
- **Etherscan‚Äëfirst UX**: All flows callable from Write tabs; guides present. **Pass** after EPIC I.

---

## 8) Specific answers to your enumerated asks

**(a) AGIALPHA at 0xA61a‚Ä¶a1fA ‚Äî does it expose public burn?**
**Yes.** Verified `AGIAlphaToken` inherits `ERC20Burnable`; the verified source shows `burn(uint256)` & `burnFrom(address,uint256)` are public, thus _callable directly by EOAs_. Decimals are 18. ([Ethereum (ETH) Blockchain Explorer][2])

**(b) TaxPolicy enforcement ‚Äúbest practices‚Äù**
Implemented via a dedicated `TaxPolicy` contract + `TaxGated` mixin and **require** checks on _every_ entrypoint used by employers, agents, validators, and dispute parties (see EPIC B). Events provide audit trails.

**(c) Expired stakes / unclaimed fees**
Kept **off platform balance sheet**; remain claimable or redistributed to validators/DAO; if burned, burning is executed by a **DAO EOA** calling `AGIALPHA.burn()` from its own wallet (not the platform). Platform never recognizes revenue.

**(d) DAO participants**
Treasury/governance may receive funds via FeePool or slashing. The **platform receives none**. Ownership handoff to multisig/timelock is documented (EPIC H; guides leverage the repo‚Äôs wiring table). ([GitHub][1])

**(e) Etherscan deployment + frontend usability docs**
Shipped as Markdown in `/docs` and are **canonical**. They mirror and expand the repo‚Äôs v2 wiring instructions and examples (module list, setters, and sample transactions). ([GitHub][1])

**ENS subdomain identity checks (16‚Äì19)**

- v1 (`AGIJobManager`) relies on ENS and includes a **NameWrapper** interface‚Äîthis confirms **fallback ownership checks** and v1‚Äëstyle `_verifyOwnership` logic to be ported. ([Ethereum (ETH) Blockchain Explorer][3])
- v2 repo text already mandates ENS identities and mentions `IdentityRegistry` & emergency allowlists. We **modularize** v1‚Äôs check into v2‚Äôs `IdentityRegistry` and **invoke it** (1) at **agent application** and (2) during **validator commit/reveal**, exactly as requested. ([GitHub][1])

---

## 9) Short ‚Äúoperator playbook‚Äù (browser‚Äëonly, day‚Äë1)

1. Deploy **TaxPolicy** ‚Üí set CID.
2. Deploy **IdentityRegistry** ‚Üí set ENS, NameWrapper, `agent.agi.eth` node, `club.agi.eth` node.
3. Deploy **StakeManager**, **FeePool**, **ReputationEngine**, **CertificateNFT**, **ValidationModule**, **DisputeModule**, **JobRegistry**.
4. Wire modules per README table (setModules, setTaxPolicy, setIdentityRegistry; back‚Äëlinks). ([GitHub][1])
5. Transfer ownership to **multisig/timelock**.
6. Publish **policy CID** + **ENS how‚Äëto** + **burn instructions** to participants.
7. Run smoke transactions (accept policy ‚Üí stake ‚Üí create job ‚Üí agent apply ‚Üí **employer burns** ‚Üí submit burn receipt ‚Üí validator commit/reveal ‚Üí approve).

---

### Why this satisfies your **TaxPolicy** + **burn** requirements

- **Platform neutrality**: contracts never receive fees or execute the burn; **validators** verify employer‚Äôs burn and shoulder the compliance duty.
- **Burn strictly via employer wallet**: the only burn path used in job flows is **`AGIALPHA.burn(amount)`** from the employer‚Äôs EOA.
- **All actors gated**: No action by employer/agent/validator/disputer without explicit **TaxPolicy acceptance**.
- **DAO/gov allowed** without platform tax exposure.
- **Identity & quality**: ENS proof parity with v1 (**NameWrapper fallback + Merkle bypass**) and commit‚Äëreveal validation.

---

## Citations

- Repo (v2‚Äëonly, ENS requirements, module wiring, Etherscan steps, setters table, AGIALPHA 18‚Äëdecimals assumption): ([GitHub][1])
- AGIALPHA token verified source; `ERC20Burnable` inheritance and `burn`/`burnFrom` availability; OZ semantics on decimals: ([Ethereum (ETH) Blockchain Explorer][2])
- v1 AGIJobManager verified on Etherscan; ENS + **NameWrapper** interface present ‚Üí basis for **\_verifyOwnership** parity: ([Ethereum (ETH) Blockchain Explorer][3])

---

[1]: https://github.com/MontrealAI/AGIJobsv2 "GitHub - MontrealAI/AGIJobsv2: ‚ú® \"We choose to free humanity from the bonds of job slavery‚Äînot because it is easy, but because our destiny demands nothing less; because doing so unleashes the full measure of our genius and spirit; and because we embrace this challenge and carry it to triumph.\" ‚ú®"
[2]: https://etherscan.io/address/0xa61a3b3a130a9c20768eebf97e21515a6046a1fa "
Address: 0xa61a3b3a...a6046a1fa | Etherscan
"
[3]: https://etherscan.io/address/0x0178b6bad606aaf908f72135b8ec32fc1d5ba477 "
Address: 0x0178b6ba...c1d5ba477 | Etherscan
"
