# AGIJobs v2 Sprint Plan and Deployment Guide

This document consolidates the final sprint plan with the operational deployment guide and reflects the production-ready configuration for AGIJobs v2.

## Summary

- Enforces ENS subdomain identities on-chain for agents and validators.
- Locks the economy to the 18‑decimal `$AGIALPHA` token.
- Emits detailed events for every stake, payment, slash, and dispute.
- Supports flexible slashing, true token burning, and fee recycling.
- Ships step‑by‑step deployment and end‑user walkthroughs tailored for Etherscan.

## Table of Contents

- [Codebase Enhancements and Key Requirements](#codebase-enhancements-and-key-requirements)
  - [ENS Subdomain Enforcement at Runtime](#ens-subdomain-enforcement-at-runtime)
  - [Exclusive Use of $AGIALPHA Token](#exclusive-use-of-agialpha-token)
  - [Comprehensive Event Logging and Traceability](#comprehensive-event-logging-and-traceability)
  - [Slashing and Staking Mechanics Optimization](#slashing-and-staking-mechanics-optimization)
  - [$AGIALPHA Burning and Fee Recycling](#agialpha-burning-and-fee-recycling)
- [Mainnet Readiness and User Experience](#mainnet-readiness-and-user-experience)
- [Step-by-Step Deployment Guide (Ethereum Mainnet via Etherscan)](#step-by-step-deployment-guide-ethereum-mainnet-via-etherscan)
- [End-User Guide: Using AGIJobs via Etherscan](#end-user-guide-using-agijobs-via-etherscan-no-coding-required)
- [Code and Documentation Quality Improvements](#code-and-documentation-quality-improvements)
- [Production-Readiness Assessment and Best Practices](#production-readiness-assessment-and-best-practices)
- [Final Deployment Recommendations](#final-deployment-recommendations)

---

## Codebase Enhancements and Key Requirements

### ENS Subdomain Enforcement at Runtime

The platform strictly enforces ENS-based identities for all participants. Agents must own a <name>.agent.agi.eth subdomain and validators a <name>.club.agi.eth subdomain, proven on-chain via the official ENS registry. The IdentityRegistry module is configured with the mainnet ENS registry and NameWrapper addresses and checks each caller’s ENS name ownership on every critical action. Bypass mechanisms (e.g. owner adding an address to an emergency allowlist) exist only for recovery and emit events (AdditionalAgentUsed/AdditionalValidatorUsed) for audit. This ensures no agent or validator can participate without a valid ENS subdomain, preserving trustless identity verification at runtime.

### Exclusive Use of $AGIALPHA Token

All payments, stakes, fees, and rewards in the system use the $AGIALPHA token (address 0xA61a3B3a130a9c20768EEBF97E21515A6046a1fA). This token address is hardcoded as a constant in the contracts, and token rotation is not supported in v2. Every module expecting an ERC-20 is linked to $AGIALPHA; for example, the StakeManager and FeePool contracts treat $AGIALPHA as the immutable staking and fee token. By hardcoding the token, the sprint will ensure $AGIALPHA remains the sole currency for staking, job payments, and rewards across the platform, eliminating any ambiguity or token misconfiguration. All economic parameters (like job rewards, stake amounts, fees) are specified in 18-decimal base units of $AGIALPHA.

### Comprehensive Event Logging and Traceability

Every significant flow of $AGIALPHA and every state change in the job lifecycle emits a structured event, facilitating complete on-chain traceability. The contracts log events for staking (StakeDeposited, StakeWithdrawn), slashing (StakeSlashed with breakdown of employer/treasury/burn portions), job creation and updates (JobCreated, ApplicationSubmitted, AgentAssigned, ResultSubmitted, JobCompleted, etc.), validation outcomes, disputes (JobDisputed, DisputeResolved), and fee distribution (FeeDeposited, FeesDistributed, FeesBurned, etc.). These events use indexed parameters (job IDs, addresses) so that block explorers like Etherscan can easily filter and display them. By enforcing thorough event emission, the sprint guarantees Etherscan-compatible logging of all $AGIALPHA movements (staking, payments, rewards, burns) and key actions, which is crucial for transparency and debugging.

### Slashing and Staking Mechanics Optimization

The staking and slashing mechanics are designed for fairness and security, and the sprint will finalize any tuning needed for quality enforcement. The StakeManager contract holds collateral stakes for agents and validators and implements flexible slashing logic. Slashing percentages for misbehavior are configurable and may sum to **at most 100%** (split between employer’s compensation and the platform treasury). Any remainder is automatically burned. For example, if a validator is slashed, a portion of their stake can be returned to the job’s employer and another portion to the treasury, with the rest burned. The sprint will ensure these percentages and minimum stake requirements (minStake) are set to sensible defaults and easily adjustable by governance. All slashing operations emit StakeSlashed events detailing the amount slashed and its distribution. By optimizing these parameters and ensuring rigorous on-chain enforcement (e.g. disallowing withdrawals during ongoing jobs or before unbonding periods), the platform maintains high quality and trust – malicious or low-quality actors risk losing stake (incentivizing honest work), and employers have financial recourse via slashing in disputes.

### $AGIALPHA Burning and Fee Recycling

To align with deflationary tokenomics and transparency, the sprint double-checks that true on-chain burning of $AGIALPHA is in effect wherever required. Rather than simply transferring fees to an inaccessible address, the contracts call the token’s `burn()` function to permanently reduce supply. **Warning:** The `burn()` function permanently reduces token supply; use it with caution. In StakeManager and FeePool, any percentage of fees or stake designated for burning triggers an on-chain burn operation (using OpenZeppelin’s ERC20Burnable interface) and emits a TokensBurned or FeesBurned event. The constant BURN_ADDRESS is set to the zero address and the contracts assert it remains zero, enforcing that burning is done by actual supply destruction, not by holding tokens in a dummy account. This approach provides Etherscan-visible proof of token burns (via events and decreasing total supply on the token contract), enhancing trust with users that fee burn mechanics are working as intended. Before deployment, confirm the $AGIALPHA token exposes a `burn(uint256)` function (e.g., via OpenZeppelin's ERC20Burnable); otherwise these burn calls will revert.

### Mainnet Readiness and User Experience

The codebase and documentation are being polished for a smooth operator and buyer experience on Ethereum mainnet. This includes ensuring all contract addresses and constants are correctly set for mainnet (e.g. using the official ENS registry address, the live $AGIALPHA token address, etc.), and that all features are toggleable or adjustable to suit real-world conditions. For example, the IdentityRegistry provides an easy one-call configureMainnet() to load the correct ENS parameters for agent.agi.eth and club.agi.eth namespaces. The sprint also emphasizes explorer usability: all public functions use primitive types and meaningful names so that Etherscan’s UI displays them clearly. Non-technical actions (like posting a job or staking) can be executed entirely through Etherscan’s Read/Write Contract tabs without custom scripts, which lowers the barrier for operators and users. Additionally, the team will verify that documentation (user guides, READMEs) covers all steps for using the platform (from obtaining an ENS name to finalizing a job) in plain language. By prioritizing mainnet deployment readiness and polishing the UX, we ensure that both platform operators (deployers) and end-users (job buyers and agent providers) can interact with AGIJobs confidently and efficiently.

## Step-by-Step Deployment Guide (Ethereum Mainnet via Etherscan)

This section provides a user-friendly, step-by-step guide to deploy the AGIJobs v2 smart contracts on Ethereum mainnet using only a web browser and Etherscan. It assumes the latest codebase is used (contracts in contracts) and that $AGIALPHA is the designated token. The guide is tailored for platform operators or administrators setting up AGIJobs, and it highlights best practices like proper module wiring, governance handoff, and ENS integration. No coding or local CLI is required beyond contract verification.

#### Prerequisites

- Ethereum wallet with enough ETH for gas
- Mainnet `$AGIALPHA` token address `0xA61a3B3a130a9c20768EEBF97E21515A6046a1fA`
- Verify on Etherscan that `$AGIALPHA` exposes `burn(uint256)`; the contracts rely on this function
- Optionally run `npx ts-node --compiler-options '{"module":"commonjs"}' scripts/check-burnable.ts` to programmatically confirm the token exposes a burn function
- Namehashes for `agent.agi.eth` and `club.agi.eth` if enforcing ENS
- Multisig or timelock address to assume governance after deployment

### 1. Deploy Each Module Contract

💡 **Note:** Use Etherscan’s **Write Contract** tab with your connected wallet for these steps — no CLI required.

Using Etherscan’s **Write Contract → Deploy** feature, deploy the core contracts one by one in the following order, providing the required constructor parameters for each. After each deployment, note the contract address. (If a constructor parameter asks for an address of a module that isn’t deployed yet, use Ethereum’s zero address `0x0000000000000000000000000000000000000000` as a temporary placeholder. You will wire the correct addresses in a later step.)
StakeManager – Parameters:
token: $AGIALPHA token address (0xA61a3B3...a1fA). Double-check this address; StakeManager treats it as immutable and the system cannot switch tokens without redeployment. The constructor also verifies that the token reports **18 decimals**—deployment will revert if the token uses a different precision.
minStake: minimum stake amount (wei). You can enter 0 to accept the default (which the contract internally sets to 1 $AGIALPHA).
employerPct & treasuryPct: the percentage of slashed stake that goes back to the job’s employer and to the treasury, respectively. For initial deployment, you may set both to 0 to use the default (which sends 100% to treasury if both are 0). Ensure that if you do set them non-zero, their sum does not exceed 100; any remainder is burned.
treasury: the address that will receive slashed funds intended for the platform. Use the zero address to burn the treasury share or supply a community treasury that has been pre-approved via `setTreasuryAllowlist`. To change this later, governance must first add the new address to the allowlist and then call `setTreasury`.
Purpose: StakeManager holds and manages all staked tokens and job escrow funds, so deploy it first to reference it in other modules.
ReputationEngine – Parameter: stakeManager address. Provide the address from step 1. This module tracks reputation scores and blacklist status of agents/validators. (No other parameters are needed; it uses sensible internal defaults for reputation calculations.)
IdentityRegistry (optional, for ENS enforcement) – Parameters:
\_ensAddress: ENS registry address (use 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e on mainnet, or 0x0 to disable ENS checks).
\_nameWrapperAddress: ENS NameWrapper address (mainnet: 0xD4416b13d2b3a9aBae7AcD5D6C2BbDBE25686401, or 0x0 if not using wrapped names).
\_reputationEngine: the ReputationEngine address from step 2 (or 0x0 if you want to deploy IdentityRegistry first and wire reputation later).
\_agentRootNode and \_clubRootNode: the namehash of agi.eth subdomains for agents and validators. On mainnet, use the provided constants for agent.agi.eth and club.agi.eth (you can find these or use the configureMainnet() function later). If you do not want to enforce ENS at launch, use 0x000...00 for these root nodes to allow anyone to participate (or set up a Merkle allowlist instead).
Purpose: This module verifies on-chain that a given address owns an ENS subdomain (and checks the ReputationEngine for blacklist). It’s optional – if omitted, you’ll rely on off-chain identity checks or emergency allowlists.
ValidationModule – Parameters:
\_jobRegistry: address placeholder (0x0 for now, since JobRegistry isn’t deployed yet).
\_stakeManager: address from step 1.
commitWindow and revealWindow: durations (in seconds) for the validator commit and reveal phases. A typical setting is 86400 (24 hours) for each.
minValidators / maxValidators: the minimum and maximum number of validators to select for each job. For example, 1 and 3 respectively (meaning each job will have between 1 and 3 validators).
validatorPool (optional): an array of validator addresses allowed to validate. Usually this can be an empty array [] to allow any staker to be chosen.
Purpose: Manages the commit–reveal process for validations and selects validators.
DisputeModule – Parameters:
\_jobRegistry: address placeholder (0x0 for now).
disputeFee: amount (in wei of $AGIALPHA) required to raise a dispute. You can set this to 0 for no fee or a value like 1000000000000000000 (1 $AGIALPHA) to deter frivolous disputes.
disputeWindow: time window (seconds) for allowing disputes after a job is completed. Choose a reasonable period (e.g. a few days in seconds).
moderator: an address of an optional dispute moderator or committee (can be an EOA, a multi-sig, or another contract). Set to 0x0 if you want disputes to be resolved by validator votes only.
Purpose: Allows escalation of job outcomes to a dispute, which can be resolved by the owner or an assigned moderator committee. Optional but recommended for quality control.
CertificateNFT – Parameters: name and symbol for the ERC-721 certificate token. For example, "AGI Jobs Certificate" and "AGIJOB".
Purpose: Issues an NFT certificate to the employer when a job is successfully completed, as a proof of completion.
FeePool – Parameters:
\_token: $AGIALPHA token address (same as in StakeManager).
\_stakeManager: address from step 1.
\_burnPct: percentage of each fee that should be burned. This is expressed 0–100 (not basis points here; e.g. enter 5 for 5%). If you want to start with burning enabled at 5%, enter 5; enter 0 to start with no burning and you can update it later.
\_treasury: address to receive any tiny rounding remainders or undistributed fees. Often the same treasury used in StakeManager. Defaults to burn if you put 0x0.
Purpose: Collects protocol fees from jobs and later distributes them to platform stakers. The FeePool also manages burning of fees (it will call burn() on the token for the given burn percentage).
PlatformRegistry (optional) – Parameters: stakeManager (from step 1), reputationEngine (from step 2), and minStake. This module can be used to register “platform” operators and enforce they stake a minimum amount to create sub-platforms. If your use case doesn’t involve multiple platforms or you’re not sure, you can skip deploying this for now.
JobRouter (optional) – Parameter: platformRegistry address (from step 8). This helps route job posts to specific sub-platforms if using PlatformRegistry. Skip if not needed.
PlatformIncentives (optional) – Parameters: stakeManager, platformRegistry, jobRouter. This manages any incentive or reward distribution across sub-platforms. Optional – skip if not used.
TaxPolicy (optional) – Parameter: a URI (as a string) pointing to the human-readable tax terms or policy. If provided, users will need to acknowledge this policy on-chain. You may deploy this to have a mutable tax disclaimer that users must accept (or skip for now and no tax acknowledgement will be required).
JobRegistry – Parameters:
validationModule: address from step 4 (fill this in now that ValidationModule is deployed).
stakeManager: address from step 1.
reputationEngine: address from step 2.
disputeModule: address from step 5.
certificateNFT: address from step 6.
identityRegistry: address from step 3 (or 0x0 if you decided not to use ENS enforcement).
taxPolicy: address from step 11 (or 0x0 if no TaxPolicy).
feePct: Protocol fee percentage (0–100). For example, 5 represents a 5% fee on each job’s reward. This fee will be taken by StakeManager and sent to FeePool upon job finalization.
jobStake: (in wei) any upfront stake an employer must put to create a job (often 0, meaning no stake required from employer aside from the job reward).
ackModules: an array of addresses for any modules that need to acknowledge job creation (usually an empty array [] – advanced use only).
owner: (if required) some modules allow specifying an initial owner; if the JobRegistry constructor requires it (depending on implementation), supply the deployer or multisig. Otherwise, ownership will default to deployer.
Purpose: The core registry coordinating jobs, linking to all other modules. This is deployed last because it needs addresses of nearly every other component.
🔹 After deploying each contract, use Etherscan’s Verify tool to publish the source code. Verifying all contracts is crucial so that their Read/Write functions are visible for interaction and so others can audit the code. (You can compile the repository locally with Hardhat to obtain the correct metadata, or use your Etherscan API key with the Hardhat verify script.)

### 2. Wire the Modules Together

Once all contracts are deployed, you need to connect them (wire them) by calling setter functions from your deployer account (which is the current owner of each module). There are two ways to do this:
Option A: Automatic Wiring via ModuleInstaller (one-call) – The repository includes an optional helper contract ModuleInstaller that can set up all links in one transaction. To use it, deploy ModuleInstaller, then temporarily transfer ownership of each module to the installer (use `transferOwnership(installer_address)` from each module’s Write tab). After that, call `ModuleInstaller.initialize(...)` with the addresses of all the deployed modules. This single call will internally invoke the necessary `set...` functions to connect module addresses (and then return ownership of each module back to you). You can include `0x0` for any modules you did not deploy (the installer will skip those). This approach is convenient and reduces chance of error. If using `IdentityRegistry`, note that `ModuleInstaller.initialize` may not cover setting it in `JobRegistry`/`ValidationModule`, so you’d still call those manually (see Option B below).
Option B: Manual Wiring (step-by-step) – You can also execute each wiring call yourself on Etherscan. Using the deployer wallet, go to each contract’s Write interface and invoke:
On JobRegistry: setModules(validationModule, stakeManager, reputationEngine, disputeModule, certificateNFT, feePool, [] ). This wires in all core module addresses, including the FeePool. (If you deployed any custom acknowledgment modules, include them in the array; otherwise use an empty array.)
On StakeManager: setJobRegistry(jobRegistry) to let the StakeManager know the JobRegistry address. Also call setDisputeModule(disputeModule) so StakeManager trusts the DisputeModule for slashing operations, and setFeePool(feePool) so protocol fees are forwarded to the FeePool.
On ValidationModule: setJobRegistry(jobRegistry) to connect it to the registry, and setIdentityRegistry(identityRegistry) if you are using ENS identities.
On DisputeModule: setJobRegistry(jobRegistry), setStakeManager(stakeManager), and setTaxPolicy(taxPolicy) if a TaxPolicy is used.
On CertificateNFT: setJobRegistry(jobRegistry) and setStakeManager(stakeManager)
— the latter now reverts unless the manager reports version 2 and the
canonical `$AGIALPHA` token — so it knows who can mint certificates and
who can verify staking.
On FeePool: setStakeManager(stakeManager) so only the designated manager can deposit fees and trigger distributions.
On JobRegistry: if not already done via setModules, also call setIdentityRegistry(identityRegistry) to enforce ENS checks on job applications, and setTaxPolicy(taxPolicy) if applicable.
If you deployed PlatformRegistry/JobRouter/PlatformIncentives: call PlatformRegistry.setRegistrar(platformIncentives, true) and JobRouter.setRegistrar(platformIncentives, true) to link the incentives module (or follow any specific instructions in their docs).
After manual wiring, double-check each module’s state via the Read Contract functions or events to ensure addresses have been set correctly. The repository provides a script (`npm run wire:verify -- --network <network>`) that can also confirm on-chain that each module has the expected references recorded in `config/agialpha.<network>.json` and `config/ens.<network>.json`.

### 3. Post-Deployment Governance and Settings

With all modules deployed and wired, perform these final steps to prepare the system for production:
Transfer Ownership to Governance: For security, it’s best practice to hand over control of each module to a multisig wallet or timelock contract (rather than an EOA) once setup is complete. Use Etherscan to call each module’s transferOwnership(governanceAddress) or setGovernance(governanceAddress) function as appropriate. For example, on StakeManager and JobRegistry call setGovernance(<multisig>), and on other modules like ValidationModule, ReputationEngine, IdentityRegistry, etc., call transferOwnership(<multisig>). (Consult the README’s deployment section or use the provided scripts/transfer-ownership.ts to do this in batch if you have many modules.) Once done, the multisig/timelock will be the only entity able to change parameters, adding an extra layer of trust. Document the governance handoff by noting an event or in your internal records.
Configure ENS (if used): If you deployed IdentityRegistry for ENS enforcement and haven’t already set the ENS root nodes, now call IdentityRegistry.setAgentRootNode(<hash>) and setClubRootNode(<hash>) with the namehashes for agent.agi.eth and club.agi.eth respectively. (On mainnet, you can use the built-in constants by calling configureMainnet() which sets the ENS registry, name wrapper, and root nodes all at once.) Also, ensure the ENS subdomains you’ll issue to agents/validators are created and owned by you (the operator) so you can assign them to users. In case you want to allow certain addresses without ENS, you can set up Merkle roots via JobRegistry.setAgentMerkleRoot / ValidationModule.setValidatorMerkleRoot and distribute Merkle proofs off-chain to those users – but this is typically an emergency measure.
Validator/Agent Allowlist Setup: If you plan to restrict who can act as agents or validators initially (for a closed beta, for example), prepare a list of addresses and either give them ENS subdomains or use the above Merkle root allowlist approach. The IdentityRegistry’s addAdditionalAgent(address) and addAdditionalValidator(address) can also temporarily whitelist specific addresses that don’t have the ENS name, but remember to remove them later – these functions emit events so you can monitor their use.
Set Initial Parameters: Through the governance address (or temporarily with deployer if you’ve not yet transferred ownership), adjust any default parameters if needed. For example, you might call StakeManager.setMinStake(amount) to require a certain minimum stake higher than the default 1 token, or JobRegistry.setFeePct(bps) if you want a protocol fee different from 5%. You can also configure the slashing percentages (StakeManager.setSlashingPercentages(employerPct, treasuryPct)) to control how slashed stake is allocated, and StakeManager.setUnbondingPeriod(seconds) to update the default 7-day unbonding delay for withdrawals. All such owner-only setters are listed in the README for reference. The design’s emphasis on owner updatability means you can fine-tune these parameters on-chain at any time via Etherscan without redeploying contracts.
Verify and Record: Ensure all contracts are verified on Etherscan (so that anyone can read the code and you can interact easily). Then record all deployed addresses and any important config (you might maintain a deployment-addresses.json as done in the repo, updating it with your mainnet addresses). It’s also wise to log any parameter changes or administrative actions (perhaps in the [AGIJobsv2 Repository](https://github.com/MontrealAI/AGIJobsv2) repo’s changelog or an internal document) for future auditability.
By following these steps, you will have a fully deployed AGIJobs v2 platform on Ethereum mainnet, with all modules connected and the system ready for use. At this point, the platform operators can start allowing jobs to be posted and fulfilled. The next section explains how end-users (job creators, agents, validators) can interact with the deployed system via Etherscan.

## End-User Guide: Using AGIJobs via Etherscan (No Coding Required)

Once the AGIJobs contracts are live on mainnet, non-technical users can interact with them directly through Etherscan’s web interface. Below is a plain-language walkthrough for typical users: employers (job buyers), agents (service providers), and validators (quality verifiers). This guide assumes the contracts are verified on Etherscan and you have the contract addresses (which the operator can share or publish).
Preparation: To use the platform, you need an Ethereum wallet (e.g. MetaMask) connected to mainnet and a supply of $AGIALPHA tokens (for staking or payments). If the platform requires ENS identities, make sure you have an ENS subdomain registered to your address (agents need one under agent.agi.eth, validators under club.agi.eth). The subdomain should resolve to your wallet address. If you don’t have this, request one from the platform operator or use their dApp to register – otherwise, the contract will reject your actions due to the identity policy (transactions will revert if you’re not the ENS owner). If ENS enforcement is not enabled, the platform might instead use an allowlist or be open to all.
With that ready, here’s how to perform key actions on AGIJobs:

1. Staking $AGIALPHA Tokens: Before taking any role, you must stake tokens via the StakeManager. On Etherscan, go to the StakeManager contract page and connect your wallet. First, use the $AGIALPHA token’s own interface (or Etherscan for the token contract) to approve the StakeManager address to spend the amount of tokens you want to stake. This is a standard ERC-20 approval transaction. Next, on StakeManager’s Write tab, find depositStake(role, amount).
   If you are an Agent looking to do jobs, call depositStake(0, <amount>) (role 0 = Agent).
   If you are a Validator, call depositStake(1, <amount>) (role 1 = Validator).
   If you want to support the platform and earn fees as a Platform staker (if allowed), role 2 is Platform.
   Enter the amount in wei (1 AGIALPHA = 1000000000000000000 wei). After this transaction, the StakeManager will hold your stake and an event StakeDeposited will confirm it. Tip: You can check your staked balance using the Read function stakes(address, role) on StakeManager.
2. Creating a Job (for Employers): As a job creator (buyer), you need to pay the reward into the contract. Ensure you have the job reward amount in $AGIALPHA. Go to the JobRegistry contract on Etherscan (Write tab). If there’s a tax policy, you might first have to call acknowledgeTaxPolicy() to agree to terms (check if JobRegistry.acknowledgeTaxPolicy exists and if your address needs it – if unsure, the platform operator will guide you). Then call createJob(reward, uri).
   reward: enter the job’s reward in wei (e.g. 5000000000000000000 for 5 AGIALPHA). This must be >= the platform’s minimum or any stake requirement. You also need to have approved the StakeManager to pull this amount from you (similar to staking). So, call the $AGIALPHA token’s approve(StakeManager, reward) first.
   uri: a link or hash (typically an IPFS URI) pointing to the job details/specifications. The platform might provide a format for this (e.g. "ipfs://Qm...hash").
   Executing createJob will transfer the reward from your wallet into escrow in the StakeManager and emit a JobCreated event with a new job ID. Make note of the jobId returned or shown in the event – this is the reference number for your job.
3. Applying for a Job (for Agents): Once a job is open (state Created), agents can apply. On JobRegistry, use applyForJob(jobId, subdomain, proof).
   jobId: the ID of the job you want to take (from the JobCreated event or provided by the employer).
   subdomain: the label of your ENS subdomain (if ENS required) – for example, if your full name is alice.agent.agi.eth, enter "alice". If ENS is not enforced or you have no subdomain, you might enter an empty string "" or whatever the platform documentation says (if allowlists via Merkle proofs are used, you may still need to provide the name you were given even if not an actual ENS name).
   proof: if the platform provided you with a Merkle proof (as an array of bytes32 values) to prove you’re on an allowlist, paste it here. Otherwise, for normal ENS usage, this can be an empty array [].
   Before applying, you must have staked tokens as an agent (see step 1). When you call applyForJob, the contract will verify your stake is sufficient and that you either own the ENS subdomain or are on the allowlist (or it will reject you). If successful, it emits ApplicationSubmitted and AgentAssigned events as it moves the job to the “Applied” state and records you as the assigned agent. At this point, the job is assigned and you can begin work off-chain to complete it.
4. Completing the Job (for Agents): After finishing the work, you (the agent) signal completion. The JobRegistry may have a two-step submission or a direct finish depending on configuration. Commonly, the agent will call submitWork(jobId, resultHash) or completeJob(jobId, resultData). Check the Write functions for something like submitJob or completeJob. If the design uses an IPFS hash of the result, you’ll provide it (e.g., a hash of the output or a URI to the result). This call will emit ResultSubmitted and move the job to Submitted state. Once submitted, the validation phase begins.
5. Validation Phase (for Validators): When a job is in Submitted state, the ValidationModule will have selected validators (often randomly or based on staked roles). If you are a validator, you need to participate by committing and revealing your validation vote. On the ValidationModule contract, use commitValidation(jobId, commitHash, subdomain, proof) during the commit window, then later revealValidation(jobId, approve, salt) during the reveal window.
   The commitHash is a hash you compute off-chain (e.g. Keccak256 of your vote and a secret salt). The platform might provide a script or you can manually do: hash = keccak256(encodePacked(approve, salt)). You’ll commit this hash first (without revealing your vote). Provide your validator ENS subdomain label as subdomain (or "" if not using ENS, plus any allowlist proof if needed similar to applyForJob).
   After all commits, when the reveal phase starts, call revealValidation with the actual approve boolean (true if you think the job was done correctly, false if not) and the salt you used. The contract will verify it matches your commit hash. If you skip commit or reveal, you might be penalized or excluded. When reveals are done, the ValidationModule tallies votes and determines a preliminary outcome (approved or not). This will emit events such as JobCompleted(jobId, success) meaning validators have finished and indicated if the job was successful. If the job passes validation, it can move to finalization; if not, it might be slashed or require disputes.
6. Finalization and Payout: Once the validation reveal window is over (and if no dispute is raised), anyone can call `ValidationModule.finalize(jobId)` to record the validators’ decision. The employer must then call `JobRegistry.acknowledgeAndFinalize(jobId)` from their own wallet. This employer‑initiated step releases the agent’s reward, routes the protocol fee to `FeePool`, and burns the configured percentage without the platform taking custody. Events such as `JobFinalized`, `RewardPaid`, and `FeesBurned` indicate completion.
7. Raising a Dispute (optional): If something went wrong – for example, the agent disagrees with a validator’s rejection or an employer thinks a validator approved bad work – a dispute can be raised. Any party (often the dissatisfied one) can call JobRegistry.raiseDispute(jobId, evidenceURI) before the dispute window expires. This will put the job into Disputed state. The evidenceURI might be an IPFS link to additional evidence. Raising a dispute may require a fee (the disputeFee you saw at deployment) which you pay alongside this transaction. Then, the DisputeModule (likely controlled by the platform’s admins or a jury) will need to resolve it. If you are the designated moderator, you’d call DisputeModule.resolve(jobId, employerWins) or a similar function to settle the outcome. This will either finalize the job in favor of the employer (meaning agent’s stake might be slashed and employer refunded) or the agent (meaning agent gets paid). As a regular user, you likely won’t call resolve – the platform operator or an assigned committee handles it.
   Throughout these interactions, ENS Subdomains and Reputation play a background role. If ENS identity is enforced, remember to use the correct subdomain string in your apply/commit calls; the contracts will internally verify you are the owner. If you ever transfer your ENS name to a different address, you’ll lose access until it’s back in your control. The ReputationEngine will update your reputation score after jobs: successful job completions will raise it, and slashes or bad behavior will lower it. Extremely low reputation could even get you automatically blacklisted from applying to future jobs (the contract can mark you as blacklisted if your score falls below a threshold, or the owner can blacklist manually). Conversely, maintaining a good reputation might unlock premium benefits. All of this happens behind the scenes, but the key takeaway is to maintain good performance to avoid penalties.
   Finally, Fee Distribution: The platform takes a fee (e.g. 5%) from each job’s reward as mentioned. Part of this fee is burned (reducing total supply, benefiting all token holders), and the rest is allocated to those staking as Platform operators. If you choose to stake in the platform (role 2) to support the network, you can later claim rewards from the FeePool contract. The FeePool’s Read functions (like pendingFees or cumulativePerToken) show how much is accumulated, and by calling FeePool.claimRewards() (if available) you withdraw your share. If no one stakes as Platform, fees are burned by default, but the platform encourages community staking to decentralize ownership of fees. For end-users, this means the ecosystem is self-sustaining: validators earn a portion of fees for their work, some tokens are burned to increase scarcity, and platform supporters earn yield from fees, all visible on-chain via events (FeesDistributed, RewardsClaimed, etc.).
   Using Etherscan’s interface: at each step, remember to connect your Web3 wallet on the Etherscan page, and double-check you’re on the correct contract address (the platform operator might publish the official addresses or even create a simple frontend, but Etherscan is the trustable fallback). All function names are designed to be human-readable and have tooltips (thanks to NatSpec comments in the contracts), so you can understand the purpose of each. If you are ever unsure, refer to the platform’s documentation or ask the operators. With these instructions, even a non-developer can participate in AGIJobs by simply executing transactions on Etherscan – no custom coding required.

## Code and Documentation Quality Improvements

After reviewing the latest AGIJobsv2 repository (v2 code), a number of improvements are recommended to ensure the code and documentation are clear, well-formatted, and user-friendly:
Consistent Coding Style: The smart contracts should adhere to a consistent style (which is largely already in place, aided by a Prettier config and linting rules in the repo). All files use the same indentation, bracket placement, and naming conventions. During the sprint, ensure any new code or changes follow this established style. Run the linter/formatter to catch deviations. Consistent style makes the code easier to read and maintain.
In-Code Documentation: The contracts make good use of NatSpec comments for functions and events, which is great for clarity and for Etherscan’s UI. We should review these comments for accuracy and completeness. Ensure every public function, parameter, and return is clearly described. For example, if any new functions are added in the sprint (e.g. additional event emitters or modifiers), document them similarly. Well-documented code helps external auditors and contributors understand the system without relying solely on external docs.
Markdown Documentation Formatting: The repository’s Markdown files (README, guides in /docs) should be polished to be self-contained and visually consistent. This means:
No external images or links that might break: All diagrams are currently provided as Markdown mermaid graphs (e.g. in architecture-v2.md) or internal references, which is good. We should double-check that any images or media are either embedded via Markdown (and stored in the repo) or drawn via mermaid, so the documentation remains fully usable offline or if external resources disappear. The README’s badges (like the MIT license badge) are external but those are standard and acceptable; beyond that, important content shouldn’t depend on external websites.
Consistent heading structure and capitalization: Ensure all documents follow a uniform hierarchy. For example, use H1 for titles, H2 for main sections, etc., and stick to either sentence case or title case for headings throughout. The README already includes a Table of Contents – maintain those in longer docs as well for easy navigation.
Clarity and brevity: Rewrite any overly complex sentences in simpler terms. The deployment guides in the repo are comprehensive; as we integrate sprint changes, confirm that instructions remain clear (as we have done above). Any new terminology introduced (e.g. “Platform Incentives”) should be explained or referenced where it first appears. Avoid jargon where possible or explain it (for instance, explain “EOA” if it’s used in docs for non-technical readers).
Visual consistency: Use formatting like bullet points, numbered steps, bold highlights, and tables in a similar style across all docs. For instance, the README uses tables to list module addresses and owner-only setters; if we add or modify such tables, ensure alignment and styling match the rest of the document. The goal is a professional, “production-grade” presentation that instills confidence.
Self-Contained Content: If there are sections in the documentation that refer to external files or images not included in the repository, consider bringing that content in. For example, if an architecture overview was only in a blog post, include a summarized version or link to an archived copy for posterity. In our review, most content seems internal, but we noticed a reference to an architecture.md (possibly an older diagram). We should either update that link to the current architecture diagram or include the relevant diagram directly. Ensuring the docs don’t rely on resources that might change or disappear makes the project docs future-proof.
Update Legacy References: Remove or clearly mark any outdated or legacy information. The repo has a legacy/ folder for deprecated v0/v1 content, which is good segregation. We should verify that the README and primary docs don’t accidentally point to legacy content unless for historical notes. Any mention of “v0” or “v1” in the main docs should likely be pruned or moved to an appendix, since new users should focus on v2. The sprint should also verify that all example addresses, function names, and outputs in the docs reflect the latest code (for instance, if any function signatures changed, update the docs accordingly).
Examples and Guides: Add more examples if needed to improve usability. The repository already provides a Quick Start with script examples (Node.js scripts for posting a job, staking, etc.). For documentation, we might incorporate those as code snippets in the guides for those who prefer CLI. The sprint might also produce a “happy path” example in the docs (some of which we have outlined in this answer) – ensure these steps are also captured in the official docs (perhaps in a user guide or FAQ). Including a flow diagram or sequence (the mermaid sequence diagram in architecture-v2.md is great for devs; we might add a more narrative example for non-devs in the README or a separate markdown).
Proofreading and Polish: Finally, proofread all user-facing text. Fix any typos, ensure consistent terminology (e.g. use “$AGIALPHA” uniformly, not sometimes “AGI Alpha” etc.), and make sure the tone is appropriate for the audience (technical docs for devs, versus simplified guides for operators/users). All these documents combined should give a new user or developer a clear understanding of how to deploy and use AGIJobs without confusion.
By addressing the above, the codebase and documentation will be clean, accessible, and professional, matching the high standards expected in a production-grade project.

## Production-Readiness Assessment and Best Practices

The latest version of AGIJobs (v2) has been evaluated for production readiness. Overall, the architecture and implementation follow solid best practices, but we highlight key points and any areas to refine:
True On-Chain Token Burning: The platform fully supports on-chain token burning as a deflationary measure. Both the StakeManager and FeePool modules are designed to permanently remove tokens from supply by calling $AGIALPHA.burn() on any fees or slashes designated to be burned. This is superior to sending tokens to a “dead” address because it transparently lowers total supply (which anyone can verify on the token contract). We confirmed that the constant burn address is zero and the contracts will revert if changed, enforcing the intended burn logic. For production, ensure the $AGIALPHA token deployed at the given address indeed has a burn(uint256) function (the repository’s test token does, and presumably the real token will be similarly burnable). If the live token did not have a burn, the contracts would need adjustment (or a different burn mechanism), but since $AGIALPHA is under the platform’s control, it should be upgradeable to include burn capability. With this in place, the platform’s economic model is deflationary: every job completed can contribute to token burning, aligning user activity with token scarcity.
Owner Updatability vs. Decentralization: The design deliberately permits the contract owner (governance) to update critical parameters and even swap out modules. This is a conscious trade-off favoring flexibility in an evolving protocol. In the current trust model, a degree of central control is acceptable – the assumption is that a multisig or governance committee will act in users’ best interest. We see that every module inherits OpenZeppelin’s Ownable, and key functions are onlyOwner gated. For instance, the owner can change fees, stakes, time windows, and even blacklist actors via the ReputationEngine. These are powerful controls that can mitigate exploits or correct issues quickly without redeployment. From a production standpoint, this is good for manageability, but users must trust the owner(s). To make this acceptable, the sprint should ensure a few things:
Encourage using a multi-signature wallet or timelock as the owner (as noted in the deployment guide) to avoid single-point-of-failure or abuse.
Emit events on all owner actions (which the contracts do, e.g. ParameterUpdated events) so changes are transparent.
Possibly set up a community oversight or at least document clearly to users that “a governance address can change X and Y”. Given this model, the contracts are upgrade-ready in the sense that the owner can point JobRegistry to new module implementations (via setModules) if a module upgrade is needed. This avoids proxy patterns while still allowing improvement – a best practice in modular smart contract design for updatability.
Security and Auditing: The code uses battle-tested libraries (OpenZeppelin for access control, reentrancy guard, SafeERC20, etc.), which is a plus. The sprint should double-check for known vulnerabilities: e.g., ensure ReentrancyGuard is applied to state-changing functions where needed (we see it used in critical places like staking and fee distribution) and that there are no unchecked transfers. The event emission and revert reasons are quite thorough, which helps with debugging and auditability. Before mainnet launch, a full security audit is recommended (if not done yet) given the complexity of modules. Part of being production-ready is having third-party audit seals or at least a comprehensive internal test suite – the repository’s test coverage (e.g., identity.test.ts, StakeManagerBurn.t.sol) should be up-to-date with final changes. During the sprint, running all tests and perhaps writing new ones for any new functionality (like any new slashing scenario or integration) would bolster confidence.
Etherscan-Based Deployment & Interaction: The system was built specifically to be deployable and operable via Etherscan, which is a huge positive for non-technical users. Functions avoid complex data types, using simple bytes32 proofs and primitive types so that input fields on Etherscan are easy to fill. The sprint should maintain this principle: any new contract or function should not require bytes encoding or fancy struct input from users. If advanced logic is needed (e.g. computing a commit hash), provide a JavaScript snippet in docs or a small tool, as has been done. The ModuleInstaller is a smart addition to ease deployment (reducing human error in wiring) – we should ensure its instructions are prominently documented for mainnet deployers. A production launch using only Etherscan is feasible (per the guide), but we might also consider eventually providing a simple UI for common actions to reduce the chance of user error (this might be beyond the scope of the sprint, but something to note for production user experience).
Token Economics and Treasury: From a production viewpoint, the platform should clarify how the treasury and fee distribution works. The code allows a treasury address to accumulate slashed tokens, while undistributed fees are burned when no staker is present. It’s important that the treasury usage is transparent – for instance, if slashed tokens go to a treasury, is that treasury controlled by governance and how will those funds be used? The contracts give flexibility (treasury address can be updated by owner and is used in both StakeManager and FeePool). Best practice would be to route these to a community-governed treasury or burn them if not needed. The sprint might want to include a note in docs or even a default: if decentralization is a goal, encourage some portion of fees to always be burned or distributed, with minimal going to a centralized treasury. However, since the trust model may allow a platform-operated treasury (for funding operations), this is acceptable – just ensure the address is set correctly in deployment and any updates are event-logged (TreasuryUpdated events exist).
Upgradability and Extensibility: The modular approach is generally robust: new modules can be introduced without affecting existing ones. For instance, one could deploy a new `ValidationModule` v3 and call `JobRegistry.setModules()` to swap it in while leaving storage intact. This avoids proxy complexity yet still allows upgrades. Ensure that any swap does not break invariants (constructor checks like `manager.version() == 2` in `ReputationEngine` help ensure compatibility). Document the procedure for upgrading a module (for example, “deploy new module, call `setModules`, then transfer ownership of all modules to a multisig or timelock, etc.”) so that if a patch is needed post-production, the team can execute it smoothly.
Performance and Scalability: On mainnet, gas costs and scaling matter. The architecture doc includes notes about gas (like validator selection cost), which is good. We should make sure any final adjustments from the sprint (like additional event logs or checks) don’t overly bloat gas. Emitting events is generally cheap compared to the actual logic, so it’s fine to err on the side of more events for transparency. The commit-reveal and Merkle proof approach for identity is gas-conscious (proofs put the heavy work off-chain). For production, parameters like maximum validators per job or maximum AGI types (the code has MAX_AGI_TYPES_CAP = 50 to prevent too large loops) are in place, which shows foresight. No immediate changes needed there, but it’s worth highlighting in documentation the practical limits (like the note in architecture about ~500 validators cap) to guide platform operators.
Emergency Controls: The presence of a SystemPause (mentioned in docs as optional) is a nice safety feature. If not already deployed, consider including SystemPause in the deployment plan, so that in an emergency, the owner can halt certain actions. This is production-friendly, as long as it’s used judiciously. Also, the emergency allowlists for identity are another safety net. The sprint doesn’t need to change those, but we should ensure operators know how to use them (and the importance of clearing them after use).
In summary, the AGIJobs v2 system is largely production-ready. It emphasizes on-chain verification, security patterns, and flexible governance – all aligning with best practices for a mainnet dApp. The sprint’s role is to double-check these mechanisms and refine documentation so that nothing is left ambiguous. After implementing the above enhancements and guides, the project will be set for a smooth mainnet launch, balancing innovation with caution.

## Final Deployment Recommendations

For a successful on-chain production deployment (using Etherscan only), here is a concise checklist of best-practice recommendations, incorporating all the points above:
Use the Verified Code: Deploy the exact code from the latest repository release. Verify each contract on Etherscan immediately after deploying (to enable the UI and community inspection).
Follow the Deployment Order and Wiring Steps: As detailed in the step-by-step guide, deploy in the correct sequence and wire the module addresses properly. Miswiring could break the system, so take advantage of the ModuleInstaller or carefully execute each set... call. Align every address with the documentation to avoid mistakes.
Ensure Token and ENS Constants are Correct: The $AGIALPHA address should be correctly set in Constants.sol – if the repository is configured for mainnet (which it is), this will be right. Confirm on Etherscan that the token implements `burn(uint256)` so on-chain burns do not revert. The ENS root node hashes for agent.agi.eth and club.agi.eth are provided in IdentityRegistry (use them via configureMainnet() or constructor). These constants make runtime enforcement possible; double-check you use them if identity is required.
Governance and Control: Deploy or have ready a multisig or timelock to administer the system. **Best Practice:** transfer ownership of all modules to this governance address immediately after deployment. Test the multisig on testnet or with a small transaction to ensure you know how to operate it (for example, proposing and executing a timelock transaction). When transferring ownership of modules, do it methodically and record each transfer. After governance handoff, test changing a minor parameter via the multisig to ensure the permissions work.
Activate Burning and Fees as Needed: Initially, you might set burnPct to 0 or low and feePct to a modest value. Once confident, you can adjust these on the fly: e.g., call FeePool.setBurnPct(5) to enable 5% burning, or JobRegistry.setFeePct(x) to tweak fees. The system’s design allows real-time tuning. Just remember any change is on-chain; consider using timelocks for parameter changes if you want to introduce a delay for community visibility (in the future).
Validator/Agent Onboarding: Before opening the platform publicly, decide how agents and validators will get their ENS subdomains or proofs. It’s a good idea to run an ENS subdomain registration process in parallel: e.g., have a simple UI or process where users request a name and you (the operator) assign it to them. The [ENS identity setup guide](ens-identity-setup.md) in the repo provides a detailed walkthrough for issuing subdomains to users. Follow that to populate your user base with the required identities. This step is crucial for a smooth user experience, otherwise many transactions will revert due to missing ENS ownership.
Trial Run on Testnet/Mainnet with Small Stakes: Do a final dry-run using a small amount of $AGIALPHA (or a test token if you deploy on a testnet first). Go through the entire job lifecycle: post a job, have an agent apply, have validators commit/reveal, finalize, maybe even try a dispute. This will confirm that everything is wired correctly and that events are showing up on Etherscan as expected. It’s much better to catch any issue (however unlikely given tests) with low stakes than after the platform is live with real users.
Monitoring and Alerts: Once live, set up monitoring with Etherscan alerts or The Graph to stay aware of disputes, slashes, or parameter changes. Because all key actions emit events, these services help you respond quickly if issues arise (such as unexpected slashes or disputes).
Community Transparency: Given the owner updatability, be transparent with your user community about it. Publish the multisig addresses, who controls them, and what the process is for changes. Consider a timelock for changes to increase trust. Also, encourage users to review the verified code themselves – the more eyes, the better in production.
By adhering to this guide and the detailed steps provided, you can confidently deploy AGIJobs v2 to mainnet in a way that is robust, traceable, and maintainable. You’ll have enforced genuine on-chain identity, a single unified token economy with $AGIALPHA, comprehensive event logs for every action, and the flexibility to manage the platform responsibly as it grows. This targeted sprint and guide together ensure that AGIJobs is ready for prime time on Ethereum.

## References

- [README.md](../README.md)
- [ens-identity-policy.md](ens-identity-policy.md)
- [IdentityRegistry.sol](../contracts/IdentityRegistry.sol)
- [Constants.sol](../contracts/Constants.sol)
- [StakeManager.sol](../contracts/StakeManager.sol)
- [FeePool.sol](../contracts/FeePool.sol)
- [architecture-v2.md](architecture-v2.md)
- [JobRegistry.sol](../contracts/JobRegistry.sol)
- [deployment-production-guide.md](deployment-production-guide.md)
- [ReputationEngine.sol](../contracts/ReputationEngine.sol)
